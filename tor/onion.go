package tor

import (
	"bytes"
	"crypto/ed25519"
	"crypto/sha512"
	"encoding/base32"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum/common"
	"golang.org/x/crypto/sha3"
)

type Onion struct {
	Address   string
	PublicKey ed25519.PublicKey
	SecretKey ed25519.PrivateKey
}

const (
	hostnameFile = "hostname"              //nolint:unused
	v3PublicFile = "hs_ed25519_public_key" //nolint:unused
	v3SecretFile = "hs_ed25519_secret_key" //nolint:unused,gosec

	v3PublicTitle = "ed25519v1-public: type0"
	v3SecretTitle = "ed25519v1-secret: type0" //nolint:gosec

	formatTitleV3 = "== %s =="
)

func (c Onion) MarshalJSON() ([]byte, error) {
	return json.Marshal(struct {
		Hostname  string `json:"hostname"`
		PublicKey []byte `json:"public_key"`
		SecretKey []byte `json:"secret_key"`
	}{
		Hostname: c.Address + ".onion",
		PublicKey: append(
			common.RightPadBytes([]byte(fmt.Sprintf(formatTitleV3, v3PublicTitle)), 32),
			c.PublicKey...,
		),
		SecretKey: append(
			common.RightPadBytes([]byte(fmt.Sprintf(formatTitleV3, v3SecretTitle)), 32),
			expandSecretKey(c.SecretKey)...,
		),
	})
}

func NewOnion(seedBytes []byte) (*Onion, error) {
	publicKey, secretKey, err := ed25519.GenerateKey(bytes.NewBuffer(seedBytes))
	if err != nil {
		return nil, err
	}
	return &Onion{
		Address:   onionAddress(publicKey),
		PublicKey: publicKey,
		SecretKey: secretKey,
	}, nil
}

// expandSecretKey Does what the blog says: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
// The blog says:
// [...]
// Ed25519 keys start life as a 32-byte (256-bit) uniformly random binary seed
// (e.g. the output of SHA256 on some random input). The seed is then hashed using SHA512, which gets you
// 64 bytes (512 bits), which is then split into a “left half” (the first 32 bytes) and a “right half”.
// The left half is massaged into a curve25519 private scalar “a” by setting and clearing a few high/low-order bits.
// The pubkey is generated by multiplying this secret scalar by “B” (the generator), which yields a 32-byte/256-bit
// group element “A”.
// [...]
// If you care more about the speed of operations than storage space, you’d want to store the expanded versions.
// Or, you might want to store as little information as possible, and accept the performance penalty of re-deriving
// things when necessary. Different implementations choose different tradeoffs.
func expandSecretKey(secretKey ed25519.PrivateKey) []byte {
	// hash = (a || RH)
	hash := sha512.Sum512(secretKey[:32])
	hash[0] &= 248
	hash[31] &= 127
	hash[31] |= 64
	return hash[:]
}

func onionAddress(publicKey ed25519.PublicKey) string {
	// checksum = H(".onion checksum" || pubkey || version)
	var checksumBytes bytes.Buffer
	checksumBytes.Write([]byte(".onion checksum"))
	checksumBytes.Write(publicKey)
	checksumBytes.Write([]byte{0x03})
	checksum := sha3.Sum256(checksumBytes.Bytes())

	// onion_address = base32(pubkey || checksum || version)
	var onionAddressBytes bytes.Buffer
	onionAddressBytes.Write(publicKey)
	onionAddressBytes.Write(checksum[:2])
	onionAddressBytes.Write([]byte{0x03})
	onionAddress := base32.StdEncoding.EncodeToString(onionAddressBytes.Bytes())

	return strings.ToLower(onionAddress)
}
